stack build
cd examples; stack ghc -- -fplugin=CoreDump.Plugin basic.hs; cd -
[ 1 of 21] Compiling Basici           ( Basici.hs, Basici.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Basici (Unit:main)\n\ninc=\\a::kind{Type} -> (\\$dNum::type{Num a_aCr} -> (\\n::type{a_aCr} -> (+ @a_aCr $dNum n fromInteger @a_aCr $dNum IS Literal(1#))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Basici\"#)\n"
[ 2 of 21] Compiling Protolude.Applicative ( Protolude/Applicative.hs, Protolude/Applicative.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Protolude.Applicative (Unit:main)\n\norAlt=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dAlternative::type{Alternative f_a11J} -> (\\$dMonoid::type{Monoid a_a11K} -> (let  ($dApplicative=$p1Alternative @f_a11J $dAlternative) in\\f::type{f_a11J a_a11K} -> (<|> @f_a11J $dAlternative @a_a11K f pure @f_a11J $dApplicative @a_a11K mempty @a_a11K $dMonoid)))))\norEmpty=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dAlternative::type{Alternative f_a11w} -> (let  ($dApplicative=$p1Alternative @f_a11w $dAlternative) in\\b::type{Bool} -> (\\a::type{a_a11x} -> (Case  (b) of  [\"False -> empty @f_a11w $dAlternative_a11y @a_a11x\",\"True -> pure @f_a11w $dApplicative_a11B @a_a11x a_aPU\"])))))\neitherA=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dAlternative::type{Alternative f_a114} -> (let  ($dApplicative=$p1Alternative @f_a114 $dAlternative) inlet  ($dFunctor=$p1Applicative @f_a114 $dApplicative) in\\a::type{f_a114 a_a115} -> (\\b::type{f_a114 b_a116} -> (<|> @f_a114 $dAlternative @Either a_a115 b_a116 <$> @f_a114 @a_a115 @Either a_a115 b_a116 $dFunctor \\ds::type{a_a115} -> (Left @a_a115 @b_a116 ds) a <$> @f_a114 @b_a116 @Either a_a115 b_a116 $dFunctor \\ds::type{b_a116} -> (Right @a_a115 @b_a116 ds) b))))))\npurer=\\f::kind{Type -> Type} -> (\\g::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dApplicative::type{Applicative f_a10M} -> (\\$dApplicative::type{Applicative g_a10N} -> (. @g_a10N a_a10O @f_a10M (g_a10N a_a10O) @a_a10O pure @f_a10M $dApplicative @g_a10N a_a10O pure @g_a10N $dApplicative @a_a10O)))))\nliftAA2=\\f::kind{Type -> Type} -> (\\g::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\c::kind{Type} -> (\\$dApplicative::type{Applicative f_a10m} -> (\\$dApplicative::type{Applicative g_a10n} -> (. @g_a10n a_a10o -> g_a10n b_a10p -> g_a10n c_a10q @f_a10m (g_a10n a_a10o)\n-> f_a10m (g_a10n b_a10p) -> f_a10m (g_a10n c_a10q) @a_a10o -> b_a10p -> c_a10q liftA2 @f_a10m $dApplicative @g_a10n a_a10o @g_a10n b_a10p @g_a10n c_a10q liftA2 @g_a10n $dApplicative @a_a10o @b_a10p @c_a10q)))))))\n<<*>>=\\f::kind{Type -> Type} -> (\\g::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dApplicative::type{Applicative f_aZZ} -> (\\$dApplicative::type{Applicative g_a100} -> (liftA2 @f_aZZ $dApplicative @g_a100 (a_a101 -> b_a102) @g_a100 a_a101 @g_a100 b_a102 <*> @g_a100 $dApplicative @a_a101 @b_a102))))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Applicative\"#)\n"
[ 3 of 21] Compiling Protolude.Base   ( Protolude/Base.hs, Protolude/Base.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base, ghc-prim}\n----\nmodule Protolude.Base (Unit:main)\n\n$!=\\a::kind{Type} -> (\\b::kind{Type} -> (\\f::type{a_a1yO -> b_a1yP} -> (\\x::type{a_a1yO} -> (Case  (x) of  [\"__DEFAULT -> f_a1yn vx_a1yp\"]))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Base\"#)\n"
[ 4 of 21] Compiling Protolude.Bool   ( Protolude/Bool.hs, Protolude/Bool.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Protolude.Bool (Unit:main)\n\nbool=\\a::kind{Type} -> (\\f::type{a_a1S7} -> (\\t::type{a_a1S7} -> (\\p::type{Bool} -> (Case  (p) of  [\"False -> f_a1Aw\",\"True -> t_a1Ax\"]))))\nwhenM=\\m::kind{Type -> Type} -> (\\$dMonad::type{Monad m_a1RS} -> (let  ($dApplicative=$p1Monad @m_a1RS $dMonad) in\\p::type{m_a1RS Bool} -> (\\m::type{m_a1RS ()} -> (>>= @m_a1RS $dMonad @Bool @() p flip @Bool @m_a1RS () @m_a1RS () when @m_a1RS $dApplicative m))))\nunlessM=\\m::kind{Type -> Type} -> (\\$dMonad::type{Monad m_a1RA} -> (let  ($dApplicative=$p1Monad @m_a1RA $dMonad) in\\p::type{m_a1RA Bool} -> (\\m::type{m_a1RA ()} -> (>>= @m_a1RA $dMonad @Bool @() p flip @Bool @m_a1RA () @m_a1RA () unless @m_a1RA $dApplicative m))))\nifM=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dMonad::type{Monad m_a1R1} -> (\\p::type{m_a1R1 Bool} -> (\\x::type{m_a1R1 a_a1R2} -> (\\y::type{m_a1R1 a_a1R2} -> (>>= @m_a1R1 $dMonad @Bool @a_a1R2 p \\b::type{Bool} -> (Case  (b) of  [\"False -> y_a1AF\",\"True -> x_a1AE\"])))))))\n||^=\\m::kind{Type -> Type} -> (\\$dMonad::type{Monad m_a1Rd} -> (\\a::type{m_a1Rd Bool} -> (\\b::type{m_a1Rd Bool} -> (ifM @m_a1Rd @Bool $dMonad a return @m_a1Rd $dMonad @Bool True b))))\n&&^=\\m::kind{Type -> Type} -> (\\$dMonad::type{Monad m_a1Rp} -> (\\a::type{m_a1Rp Bool} -> (\\b::type{m_a1Rp Bool} -> (ifM @m_a1Rp @Bool $dMonad a b return @m_a1Rp $dMonad @Bool False))))\nguardM=\\m::kind{Type -> Type} -> (\\$dMonadPlus::type{MonadPlus m_a1QM} -> (let  ($dMonad=$p2MonadPlus @m_a1QM $dMonadPlus) inlet  ($dAlternative=$p1MonadPlus @m_a1QM $dMonadPlus) in\\f::type{m_a1QM Bool} -> (=<< @m_a1QM @Bool @() $dMonad guard @m_a1QM $dAlternative f)))\n<||>=\\a::kind{Type -> Type} -> (\\$dApplicative::type{Applicative a_a1QC} -> (liftA2 @a_a1QC $dApplicative @Bool @Bool @Bool ||))\n<&&>=\\a::kind{Type -> Type} -> (\\$dApplicative::type{Applicative a_a1Qs} -> (liftA2 @a_a1Qs $dApplicative @Bool @Bool @Bool &&))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Bool\"#)\n"
[ 5 of 21] Compiling Protolude.CallStack ( Protolude/CallStack.hs, Protolude/CallStack.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Protolude.CallStack (Unit:main)\n\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.CallStack\"#)\n"
[ 6 of 21] Compiling Protolude.Conv   ( Protolude/Conv.hs, Protolude/Conv.o ) [Impure plugin forced recompilation]
"[StringConv, Leniency]\n----\n{(main, Protolude.Base)}\n\n{base, bytestring-0.11.3.1, text-2.0.1}\n----\nmodule Protolude.Conv (Unit:main)\n\n$cstrConv=\\ds::type{Leniency} -> (id @String)\n$fStringConv[][]=UTCast($cstrConv~Sym (N:StringConv[0] <String>_N <String>_N))\n$cstrConv=\\ds::type{Leniency} -> (pack)\n$fStringConv[]ByteString0=UTCast($cstrConv~Sym (N:StringConv[0] <String>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (pack)\n$fStringConv[]ByteString=UTCast($cstrConv~Sym (N:StringConv[0] <String>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (pack)\n$fStringConv[]Text0=UTCast($cstrConv~Sym (N:StringConv[0] <String>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (pack)\n$fStringConv[]Text=UTCast($cstrConv~Sym (N:StringConv[0] <String>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (unpack)\n$fStringConvByteString[]0=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <String>_N))\n$cstrConv=\\ds::type{Leniency} -> (id @ByteString)\n$fStringConvByteStringByteString2=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (. @[ByteString] @ByteString @ByteString fromChunks pure @[] $fApplicative[] @ByteString)\n$fStringConvByteStringByteString1=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (unpack)\n$fStringConvByteString[]=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <String>_N))\n$cstrConv=\\ds::type{Leniency} -> (. @[ByteString] @ByteString @ByteString concat toChunks)\n$fStringConvByteStringByteString0=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (id @ByteString)\n$fStringConvByteStringByteString=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (unpack)\n$fStringConvText[]0=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <String>_N))\n$cstrConv=\\ds::type{Leniency} -> (encodeUtf8)\n$fStringConvTextByteString2=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <ByteString>_N))\n$cstrConv=\\l::type{Leniency} -> (. @ByteString @ByteString @Text strConv @ByteString @ByteString $fStringConvByteStringByteString1 l encodeUtf8)\n$fStringConvTextByteString1=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <ByteString>_N))\n$cstrConv=\\ds::type{Leniency} -> (fromStrict)\n$fStringConvTextText2=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (id @Text)\n$fStringConvTextText1=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (unpack)\n$fStringConvText[]=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <String>_N))\n$cstrConv=\\ds::type{Leniency} -> (toStrict)\n$fStringConvTextText0=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (id @Text)\n$fStringConvTextText=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (encodeUtf8)\n$fStringConvTextByteString0=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <ByteString>_N))\n$cstrConv=\\l::type{Leniency} -> (. @ByteString @ByteString @Text strConv @ByteString @ByteString $fStringConvByteStringByteString0 l encodeUtf8)\n$fStringConvTextByteString=UTCast($cstrConv~Sym (N:StringConv[0] <Text>_N <ByteString>_N))\n$fBoundedLeniency=C:Bounded @Leniency Lenient Strict\n$cfromEnum=\\a::type{Leniency} -> (Case  (dataToTag# @Leniency a) of  [\"__DEFAULT -> I# a#_a2GR\"])\n$c<=\\a::type{Leniency} -> (\\b::type{Leniency} -> (Case  (a) of  [\"Lenient ->\\n  case b_a2Gy of {\\n    __DEFAULT -> True;\\n    Lenient -> False\\n  }\",\"Strict ->\\n  case b_a2Gy of {\\n    __DEFAULT -> False;\\n    Strict -> False\\n  }\"]))\n$ccompare=\\a::type{Leniency} -> (\\b::type{Leniency} -> (Case  (a) of  [\"Lenient ->\\n  case b_a2Gw of {\\n    __DEFAULT -> LT;\\n    Lenient -> EQ\\n  }\",\"Strict ->\\n  case b_a2Gw of {\\n    __DEFAULT -> GT;\\n    Strict -> EQ\\n  }\"]))\n$cshowsPrec=\\ds::type{Int} -> (\\ds::type{Leniency} -> (Case  (ds) of  [\"Lenient -> showString (unpackCString# \\\"Lenient\\\"#)\",\"Strict -> showString (unpackCString# \\\"Strict\\\"#)\"]))\n\nREC {\n$fShowLeniency = C:Show @Leniency $cshowsPrec $cshow $cshowList\n$cshowList = \\ls::type{[Leniency]} -> (\\s::type{String} -> (showList__ @Leniency showsPrec @Leniency $fShowLeniency I# Literal(0#) ls s))\n$cshow = \\x::type{Leniency} -> (showsPrec @Leniency $fShowLeniency I# Literal(0#) x [] @Char)\n\n}\n\n\n$c===\\a::type{Leniency} -> (\\b::type{Leniency} -> (Case  (dataToTag# @Leniency a) of  [\"__DEFAULT ->\\n  case dataToTag# @Leniency b_a2Gs of b#_a2Gu { __DEFAULT ->\\n  tagToEnum# @Bool (==# a#_a2Gt b#_a2Gu)\\n  }\"]))\n\nREC {\n$fEqLeniency = C:Eq @Leniency $c== $c/=\n$c/= = \\x::type{Leniency} -> (\\y::type{Leniency} -> (Case  (== @Leniency $fEqLeniency x y) of  [\"False -> True\",\"True -> False\"]))\n\n}\n\n\n\nREC {\n$fOrdLeniency = C:Ord @Leniency $fEqLeniency $ccompare $c< $c<= $c> $c>= $cmax $cmin\n$cmax = \\x::type{Leniency} -> (\\y::type{Leniency} -> (Case  (<= @Leniency $fOrdLeniency x y) of  [\"False -> x_a32k\",\"True -> y_a32l\"]))\n$c>= = \\a::type{Leniency} -> (\\b::type{Leniency} -> (not < @Leniency $fOrdLeniency a b))\n$c> = \\a::type{Leniency} -> (\\b::type{Leniency} -> (< @Leniency $fOrdLeniency b a))\n$cmin = \\x::type{Leniency} -> (\\y::type{Leniency} -> (Case  (<= @Leniency $fOrdLeniency x y) of  [\"False -> y_a32s\",\"True -> x_a32r\"]))\n$c<= = \\a::type{Leniency} -> (\\b::type{Leniency} -> (not < @Leniency $fOrdLeniency b a))\n\n}\n\n\ntoS=\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dStringConv::type{StringConv a_a2OF b_a2OG} -> (strConv @a_a2OF @b_a2OG $dStringConv Strict)))\ntoSL=\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dStringConv::type{StringConv a_a2Ow b_a2Ox} -> (strConv @a_a2Ow @b_a2Ox $dStringConv Lenient)))\ndecodeUtf8T=\\ds::type{Leniency} -> (Case  (ds) of  [\"Lenient -> decodeUtf8With lenientDecode\",\"Strict -> decodeUtf8With strictDecode\"])\n$cstrConv=\\l::type{Leniency} -> (. @ByteString @Text @ByteString decodeUtf8T l strConv @ByteString @ByteString $fStringConvByteStringByteString0 l)\n$fStringConvByteStringText0=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <Text>_N))\n$fStringConvByteStringText2=UTCast(decodeUtf8T~Sym (N:StringConv[0] <ByteString>_N <Text>_N))\n$cstrConv=\\ds::type{Leniency} -> (Case  (ds) of  [\"Lenient -> decodeUtf8With lenientDecode\",\"Strict -> decodeUtf8With strictDecode\"])\n$fStringConvByteStringText=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <Text>_N))\n$cstrConv=\\l::type{Leniency} -> (. @ByteString @Text @ByteString strConv @ByteString @Text $fStringConvByteStringText l . @[ByteString] @ByteString @ByteString fromChunks pure @[] $fApplicative[] @ByteString)\n$fStringConvByteStringText1=UTCast($cstrConv~Sym (N:StringConv[0] <ByteString>_N <Text>_N))\n$tag2con_Leniency=\\ds::type{Int} -> (Case  (ds) of  [\"I# a_a2Gq -> tagToEnum# @Leniency a_a2Gq\"])\n$cpred=let  ($dIP=UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"error\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Conv\"#) unpackCString# Literal(\"./Protolude/Conv.hs\"#) I# Literal(31#) I# Literal(25#) I# Literal(31#) I# Literal(29#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N))) in\\a::type{Leniency} -> (Case  (dataToTag# @Leniency a) of  [\"__DEFAULT ->\\n  case == @Int $fEqInt (I# 0#) (I# a#_a2GI) of {\\n    False ->\\n      $tag2con_Leniency_a2Go (+ @Int $fNumInt (I# a#_a2GI) (I# -1#));\\n    True ->\\n      error\\n        @LiftedRep\\n        @Leniency\\n        $dIP_a2Sm\\n        (unpackCString#\\n           \\\"pred{Leniency}: tried to take `pred' of first tag in enumeration\\\"#)\\n  }\"])\n$maxtag_Leniency=I# Literal(1#)\n$csucc=let  ($dIP=UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"error\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Conv\"#) unpackCString# Literal(\"./Protolude/Conv.hs\"#) I# Literal(31#) I# Literal(25#) I# Literal(31#) I# Literal(29#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N))) in\\a::type{Leniency} -> (Case  (dataToTag# @Leniency a) of  [\"__DEFAULT ->\\n  case == @Int $fEqInt $maxtag_Leniency_a2Gp (I# a#_a2GG) of {\\n    False ->\\n      $tag2con_Leniency_a2Go (+ @Int $fNumInt (I# a#_a2GG) (I# 1#));\\n    True ->\\n      error\\n        @LiftedRep\\n        @Leniency\\n        $dIP_a2S5\\n        (unpackCString#\\n           \\\"succ{Leniency}: tried to take `succ' of last tag in enumeration\\\"#)\\n  }\"])\n$ctoEnum=let  ($dIP=UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"error\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Conv\"#) unpackCString# Literal(\"./Protolude/Conv.hs\"#) I# Literal(31#) I# Literal(25#) I# Literal(31#) I# Literal(29#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N))) in\\a::type{Int} -> (Case  (&& >= @Int $fOrdInt a I# Literal(0#) <= @Int $fOrdInt a $maxtag_Leniency) of  [\"False ->\\n  error\\n    @LiftedRep\\n    @Leniency\\n    $dIP_a2SB\\n    (++\\n       @Char\\n       (unpackCString# \\\"toEnum{Leniency}: tag (\\\"#)\\n       (showsPrec\\n          @Int\\n          $fShowInt\\n          (I# 0#)\\n          a_a2GJ\\n          (++\\n             @Char\\n             (unpackCString# \\\") is outside of enumeration's range (0,\\\"#)\\n             (showsPrec\\n                @Int\\n                $fShowInt\\n                (I# 0#)\\n                $maxtag_Leniency_a2Gp\\n                (unpackCString# \\\")\\\"#)))))\",\"True -> $tag2con_Leniency_a2Go a_a2GJ\"])\n$cenumFrom=\\a::type{Leniency} -> (Case  (dataToTag# @Leniency a) of  [\"__DEFAULT ->\\n  map\\n    @Int\\n    @Leniency\\n    $tag2con_Leniency_a2Go\\n    (enumFromTo @Int $fEnumInt (I# a#_a2GL) $maxtag_Leniency_a2Gp)\"])\n$cenumFromThen=\\a::type{Leniency} -> (\\b::type{Leniency} -> (Case  (dataToTag# @Leniency a) of  [\"__DEFAULT ->\\n  case dataToTag# @Leniency b_a2GN of b#_a2GP { __DEFAULT ->\\n  map\\n    @Int\\n    @Leniency\\n    $tag2con_Leniency_a2Go\\n    (enumFromThenTo\\n       @Int\\n       $fEnumInt\\n       (I# a#_a2GO)\\n       (I# b#_a2GP)\\n       (case > @Int $fOrdInt (I# a#_a2GO) (I# b#_a2GP) of {\\n          False -> $maxtag_Leniency_a2Gp;\\n          True -> I# 0#\\n        }))\\n  }\"]))\n\nREC {\n$fEnumLeniency = C:Enum @Leniency $csucc $cpred $ctoEnum $cfromEnum $cenumFrom $cenumFromThen $cenumFromTo $cenumFromThenTo\n$cenumFromThenTo = \\x1::type{Leniency} -> (\\x2::type{Leniency} -> (\\y::type{Leniency} -> (build @Leniency \\b1::kind{Type} -> (\\c::type{Leniency -> b1_a32D -> b1_a32D} -> (\\n::type{b1_a32D} -> (Case  (fromEnum @Leniency $fEnumLeniency x1) of  [\"I# x4_a32H ->\\n  case fromEnum @Leniency $fEnumLeniency x2_a32z of { I# x5_a32K ->\\n  case fromEnum @Leniency $fEnumLeniency y_a32A of { I# y1_a32R ->\\n  efdtIntFB\\n    @b1_a32D\\n    (mapFB\\n       @Leniency @b1_a32D @Int c_a32E (toEnum @Leniency $fEnumLeniency))\\n    n_a32F\\n    x4_a32H\\n    x5_a32K\\n    y1_a32R\\n  }\\n  }\"]))))))\n$cenumFromTo = \\x::type{Leniency} -> (\\y::type{Leniency} -> (build @Leniency \\b1::kind{Type} -> (\\c::type{Leniency -> b1_a32X -> b1_a32X} -> (\\n::type{b1_a32X} -> (Case  (fromEnum @Leniency $fEnumLeniency x) of  [\"I# x1_a331 ->\\n  case fromEnum @Leniency $fEnumLeniency y_a32W of { I# y1_a335 ->\\n  eftIntFB\\n    @b1_a32X\\n    (mapFB\\n       @Leniency @b1_a32X @Int c_a32Y (toEnum @Leniency $fEnumLeniency))\\n    n_a32Z\\n    x1_a331\\n    y1_a335\\n  }\"])))))\n\n}\n\n\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Conv\"#)\n$krep=KindRepTyConApp $tcConstraint [] @KindRep\n$krep=KindRepFun krep$* $krep\n$krep=KindRepFun krep$* $krep\n$krep=$WKindRepVar I# Literal(1#)\n$krep=$WKindRepVar I# Literal(0#)\n$krep=KindRepFun $krep $krep\n$tcLeniency=TyCon Literal(13951273592991311478##64) Literal(17656875755886477397##64) $trModule TrNameS Literal(\"Leniency\"#) Literal(0#) krep$*\n$krep=KindRepTyConApp $tcLeniency [] @KindRep\n$tc'Lenient=TyCon Literal(5931801755404709404##64) Literal(13492376530877148108##64) $trModule TrNameS Literal(\"'Lenient\"#) Literal(0#) $krep\n$tc'Strict=TyCon Literal(16814822370794902399##64) Literal(17394854805391877767##64) $trModule TrNameS Literal(\"'Strict\"#) Literal(0#) $krep\n$krep=KindRepFun $krep $krep\n$tcStringConv=TyCon Literal(955053367058747583##64) Literal(16955558172122020002##64) $trModule TrNameS Literal(\"StringConv\"#) Literal(0#) $krep\n$krep=KindRepTyConApp $tcStringConv : @KindRep $krep : @KindRep $krep [] @KindRep\n$krep=KindRepFun $krep $krep\n$tc'C:StringConv=TyCon Literal(5714587195814975397##64) Literal(16863130113204897777##64) $trModule TrNameS Literal(\"'C:StringConv\"#) Literal(2#) $krep\n"
[ 7 of 21] Compiling Protolude.ConvertText ( Protolude/ConvertText.hs, Protolude/ConvertText.o ) [Impure plugin forced recompilation]
"[ConvertText]\n----\n{}\n\n{base, bytestring-0.11.3.1, text-2.0.1}\n----\nmodule Protolude.ConvertText (Unit:main)\n\n$fConvertText[][]=UTCast(id @String~Sym (N:ConvertText[0]) <String>_N <String>_N)\n$fConvertText[]Text0=UTCast(pack~Sym (N:ConvertText[0]) <String>_N <Text>_N)\n$fConvertText[]Text=UTCast(pack~Sym (N:ConvertText[0]) <String>_N <Text>_N)\n$fConvertTextText[]0=UTCast(unpack~Sym (N:ConvertText[0]) <Text>_N <String>_N)\n$fConvertTextTextText2=UTCast(fromStrict~Sym (N:ConvertText[0]) <Text>_N <Text>_N)\n$fConvertTextTextText1=UTCast(id @Text~Sym (N:ConvertText[0]) <Text>_N <Text>_N)\n$fConvertTextText[]=UTCast(unpack~Sym (N:ConvertText[0]) <Text>_N <String>_N)\n$fConvertTextTextText0=UTCast(toStrict~Sym (N:ConvertText[0]) <Text>_N <Text>_N)\n$fConvertTextTextText=UTCast(id @Text~Sym (N:ConvertText[0]) <Text>_N <Text>_N)\n$fConvertTextByteStringByteString2=UTCast(toStrict~Sym (N:ConvertText[0]) <ByteString>_N <ByteString>_N)\n$fConvertTextByteStringByteString1=UTCast(id @ByteString~Sym (N:ConvertText[0]) <ByteString>_N <ByteString>_N)\n$fConvertTextByteStringByteString0=UTCast(id @ByteString~Sym (N:ConvertText[0]) <ByteString>_N <ByteString>_N)\n$fConvertTextByteStringByteString=UTCast(fromStrict~Sym (N:ConvertText[0]) <ByteString>_N <ByteString>_N)\ntoUtf8=\\a::kind{Type} -> (\\$dConvertText::type{ConvertText a_a3IU Text} -> (. @Text @ByteString @a_a3IU encodeUtf8 toS @a_a3IU @Text $dConvertText))\ntoUtf8Lazy=\\a::kind{Type} -> (\\$dConvertText::type{ConvertText a_a3IG Text} -> (. @ByteString @ByteString @a_a3IG fromStrict . @Text @ByteString @a_a3IG encodeUtf8 toS @a_a3IG @Text $dConvertText))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.ConvertText\"#)\n$krep=KindRepTyConApp $tcConstraint [] @KindRep\n$krep=KindRepFun krep$* $krep\n$krep=KindRepFun krep$* $krep\n$krep=$WKindRepVar I# Literal(1#)\n$krep=$WKindRepVar I# Literal(0#)\n$krep=KindRepFun $krep $krep\n$tcConvertText=TyCon Literal(5478174223899902812##64) Literal(13650905200517222219##64) $trModule TrNameS Literal(\"ConvertText\"#) Literal(0#) $krep\n$krep=KindRepTyConApp $tcConvertText : @KindRep $krep : @KindRep $krep [] @KindRep\n$krep=KindRepFun $krep $krep\n$tc'C:ConvertText=TyCon Literal(10830055866350876096##64) Literal(11051149829859188598##64) $trModule TrNameS Literal(\"'C:ConvertText\"#) Literal(2#) $krep\n"
[ 8 of 21] Compiling Protolude.Either ( Protolude/Either.hs, Protolude/Either.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Protolude.Either (Unit:main)\n\nleftToMaybe=\\l::kind{Type} -> (\\r::kind{Type} -> (either @l_a3QC @Maybe l_a3QC @r_a3QD \\ds::type{l_a3QC} -> (Just @l_a3QC ds) const @Maybe l_a3QC @r_a3QD Nothing @l_a3QC))\nrightToMaybe=\\l::kind{Type} -> (\\r::kind{Type} -> (either @l_a3Ql @Maybe r_a3Qm @r_a3Qm const @Maybe r_a3Qm @l_a3Ql Nothing @r_a3Qm \\ds::type{r_a3Qm} -> (Just @r_a3Qm ds)))\nmaybeToRight=\\l::kind{Type} -> (\\r::kind{Type} -> (\\l::type{l_a3Q9} -> (maybe @Either l_a3Q9 r_a3Qa @r_a3Qa Left @l_a3Q9 @r_a3Qa l \\ds::type{r_a3Qa} -> (Right @l_a3Q9 @r_a3Qa ds))))\nmaybeToLeft=\\r::kind{Type} -> (\\l::kind{Type} -> (\\r::type{r_a3PX} -> (maybe @Either l_a3PY r_a3PX @l_a3PY Right @l_a3PY @r_a3PX r \\ds::type{l_a3PY} -> (Left @l_a3PY @r_a3PX ds))))\nmaybeEmpty=\\b::kind{Type} -> (\\a::kind{Type} -> (\\$dMonoid::type{Monoid b_a3PL} -> (maybe @b_a3PL @a_a3PM mempty @b_a3PL $dMonoid)))\nmaybeToEither=\\e::kind{Type} -> (\\a::kind{Type} -> (\\e::type{e_a3Pz} -> (\\ds::type{Maybe a_a3PA} -> (Case  (ds) of  [\"Nothing -> Left @e_a3Pz @a_a3PA e_a3Nr\",\"Just a_a3Ns -> Right @e_a3Pz @a_a3PA a_a3Ns\"]))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Either\"#)\n"
[ 9 of 21] Compiling Protolude.Error  ( Protolude/Error.hs, Protolude/Error.o ) [Impure plugin forced recompilation]
"[]\n----\n{(main, Protolude.CallStack)}\n\n{base, ghc-prim, text-2.0.1}\n----\nmodule Protolude.Error (Unit:main)\n\nerror=\\r::kind{RuntimeRep} -> (\\a::kind{TYPE r_a3Wq} -> (\\$dIP::type{HasCallStack} -> (\\s::type{Text} -> (raise# @'Lifted @r_a3Wq @SomeException @a_a3Wr errorCallWithCallStackException unpack s UTCast($dIP~N:IP[0] <\"callStack\">_N <CallStack>_N)))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Error\"#)\n"
[10 of 21] Compiling Protolude.Exceptions ( Protolude/Exceptions.hs, Protolude/Exceptions.o ) [Impure plugin forced recompilation]
"[]\n----\n{(main, Protolude.Base)}\n\n{base, mtl-2.2.2}\n----\nmodule Protolude.Exceptions (Unit:main)\n\nhush=\\m::kind{Type -> Type} -> (\\e::kind{Type} -> (\\a::kind{Type} -> (\\$dAlternative::type{Alternative m_a541} -> (let  ($dApplicative=$p1Alternative @m_a541 $dAlternative) in\\ds::type{Either e_a542 a_a543} -> (Case  (ds) of  [\"Left _ [Occ=Dead] -> empty @m_a541 $dAlternative_a544 @a_a543\",\"Right x_a4Z4 -> pure @m_a541 $dApplicative_a54c @a_a543 x_a4Z4\"])))))\nnote=\\e::kind{Type} -> (\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dMonadError::type{MonadError e_a53K m_a53L} -> (let  ($dApplicative=$p1Monad @m_a53L $p1MonadError @e_a53K @m_a53L $dMonadError) in\\err::type{e_a53K} -> (maybe @m_a53L a_a53M @a_a53M throwError @e_a53K @m_a53L $dMonadError @a_a53M err pure @m_a53L $dApplicative @a_a53M)))))\ntryIO=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dMonadIO::type{MonadIO m_a53j} -> (. @m_a53j (Either IOException a_a53k) @ExceptT IOException m_a53j a_a53k @IO a_a53k \\ds::type{m_a53j (Either IOException a_a53k)} -> (UTCast(ds~Sym (N:ExceptT[0] <IOException>_N <m_a53j>_R <a_a53k>_N))) . @IO (Either IOException a_a53k) @m_a53j (Either IOException a_a53k) @IO a_a53k liftIO @m_a53j $dMonadIO @Either IOException a_a53k try @IOException @a_a53k $fExceptionIOException)))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Exceptions\"#)\n"
[11 of 21] Compiling Protolude.Functor ( Protolude/Functor.hs, Protolude/Functor.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Protolude.Functor (Unit:main)\n\n<<$>>=\\f::kind{Type -> Type} -> (\\g::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dFunctor::type{Functor f_a5ea} -> (\\$dFunctor::type{Functor g_a5eb} -> (. @g_a5eb a_a5ec -> g_a5eb b_a5ed @f_a5ea (g_a5eb a_a5ec) -> f_a5ea (g_a5eb b_a5ed) @a_a5ec -> b_a5ed fmap @f_a5ea $dFunctor @g_a5eb a_a5ec @g_a5eb b_a5ed fmap @g_a5eb $dFunctor @a_a5ec @b_a5ed))))))\nforeach=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dFunctor::type{Functor f_a5dU} -> (flip @a_a5dV -> b_a5dW @f_a5dU a_a5dV @f_a5dU b_a5dW fmap @f_a5dU $dFunctor @a_a5dV @b_a5dW))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Functor\"#)\n"
[12 of 21] Compiling Protolude.List   ( Protolude/List.hs, Protolude/List.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base, containers-0.6.6}\n----\nmodule Protolude.List (Unit:main)\n\nhead=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dFoldable::type{Foldable f_a5Cx} -> (foldr @f_a5Cx $dFoldable @a_a5Cy @Maybe a_a5Cy \\x::type{a_a5Cy} -> (\\ds::type{Maybe a_a5Cy} -> (pure @Maybe $fApplicativeMaybe @a_a5Cy x)) Nothing @a_a5Cy)))\nsortOn=\\o::kind{Type} -> (\\a::kind{Type} -> (\\$dOrd::type{Ord o_a5Ch} -> (. @a_a5Ci -> a_a5Ci -> Ordering @[a_a5Ci] -> [a_a5Ci] @a_a5Ci -> o_a5Ch sortBy @a_a5Ci comparing @o_a5Ch @a_a5Ci $dOrd)))\nordNub=\\a::kind{Type} -> (\\$dOrd::type{Ord a_a5Bd} -> (\\l::type{[a_a5Bd]} -> (let  (\nREC {\ngo = \\ds::type{Set a_a5Bd} -> (\\ds::type{[a_a5Bd]} -> (Case  (ds) of  [\"[] -> [] @a_a5Bd\",\": x_a5tN xs_a5tO ->\\n  case member @a_a5Bd $dOrd_a5Be x_a5tN ds_d5Dc of {\\n    False ->\\n      : @a_a5Bd\\n        x_a5tN\\n        (go_a5Bi (insert @a_a5Bd $dOrd_a5Be x_a5tN ds_d5Dc) xs_a5tO);\\n    True -> go_a5Bi ds_d5Dc xs_a5tO\\n  }\"]))\n\n}\n\n) ingo empty @a_a5Bd l)))\nlist=\\b::kind{Type} -> (\\a::kind{Type} -> (\\def::type{[b_a5B1]} -> (\\f::type{a_a5B2 -> b_a5B1} -> (\\xs::type{[a_a5B2]} -> (Case  (xs) of  [\"__DEFAULT -> fmap @[] $fFunctor[] @a_a5B2 @b_a5B1 f_a5xZ xs_a5y0\",\"[] -> def_a5xY\"])))))\nproduct=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dFoldable::type{Foldable f_a5AM} -> (\\$dNum::type{Num a_a5AN} -> (foldl' @f_a5AM $dFoldable @a_a5AN @a_a5AN * @a_a5AN $dNum fromInteger @a_a5AN $dNum IS Literal(1#)))))\nsum=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dFoldable::type{Foldable f_a5Av} -> (\\$dNum::type{Num a_a5Aw} -> (foldl' @f_a5Av $dFoldable @a_a5Aw @a_a5Aw + @a_a5Aw $dNum fromInteger @a_a5Aw $dNum IS Literal(0#)))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.List\"#)\n"
[13 of 21] Compiling Protolude.Monad  ( Protolude/Monad.hs, Protolude/Monad.o ) [Impure plugin forced recompilation]
"[]\n----\n{(main, Protolude.Base)}\n\n{base}\n----\nmodule Protolude.Monad (Unit:main)\n\nconcatMapM=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dMonad::type{Monad m_a5Ne} -> (\\f::type{a_a5Nf -> m_a5Ne [b_a5Ng]} -> (\\xs::type{[a_a5Nf]} -> (liftM @m_a5Ne @[[b_a5Ng]] @[b_a5Ng] $dMonad concat @[] @b_a5Ng $fFoldable[] mapM @[] $fTraversable[] @m_a5Ne @a_a5Nf @[b_a5Ng] $dMonad f xs))))))\nliftM'=<$!>\nliftM2'=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\c::kind{Type} -> (\\$dMonad::type{Monad m_a5Mx} -> (\\eta::type{a_a5My -> b_a5Mz -> c_a5MA} -> (\\eta::type{m_a5Mx a_a5My} -> (\\b::type{m_a5Mx b_a5Mz} -> (>>= @m_a5Mx $dMonad @a_a5My @c_a5MA eta \\x::type{a_a5My} -> (>>= @m_a5Mx $dMonad @b_a5Mz @c_a5MA b \\y::type{b_a5Mz} -> (Case  (eta x y) of  [\"__DEFAULT -> return @m_a5Mx $dMonad_a5MB @c_a5MA z_X2\"]))))))))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Monad\"#)\n"
[14 of 21] Compiling Protolude.Panic  ( Protolude/Panic.hs, Protolude/Panic.o ) [Impure plugin forced recompilation]
"[FatalError]\n----\n{(main, Protolude.Base), (main, Protolude.CallStack)}\n\n{base, text-2.0.1}\n----\nmodule Protolude.Panic (Unit:main)\n\n$cshowsPrec=\\a::type{Int} -> (\\ds::type{FatalError} -> (showParen >= @Int $fOrdInt a I# Literal(11#) . @String @String @String showString unpackCString# Literal(\"FatalError {\"#) . @String @String @String showString unpackCString# Literal(\"fatalErrorMessage = \"#) . @String @String @String showsPrec @Text $fShowText I# Literal(0#) UTCast(ds~N:FatalError[0]) showString unpackCString# Literal(\"}\"#)))\n\nREC {\n$fShowFatalError = C:Show @FatalError $cshowsPrec $cshow $cshowList\n$cshowList = \\ls::type{[FatalError]} -> (\\s::type{String} -> (showList__ @FatalError showsPrec @FatalError $fShowFatalError I# Literal(0#) ls s))\n$cshow = \\x::type{FatalError} -> (showsPrec @FatalError $fShowFatalError I# Literal(0#) x [] @Char)\n\n}\n\n\nfatalErrorMessage=\\ds::type{FatalError} -> (UTCast(ds~N:FatalError[0]))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Panic\"#)\n$krep=KindRepTyConApp $tcText [] @KindRep\n$tcFatalError=TyCon Literal(17272582496974148528##64) Literal(4946215054026057704##64) $trModule TrNameS Literal(\"FatalError\"#) Literal(0#) krep$*\n$krep=KindRepTyConApp $tcFatalError [] @KindRep\n$krep=KindRepFun $krep $krep\n$tc'FatalError=TyCon Literal(8350705662628850422##64) Literal(15924095852248932533##64) $trModule TrNameS Literal(\"'FatalError\"#) Literal(0#) $krep\n$cp1Exception=UTCast(mkTrCon @Type @FatalError $tcFatalError [] @SomeTypeRep~Sym (N:Typeable[0]) <Type>_N <FatalError>_N)\n\nREC {\n$fExceptionFatalError = C:Exception @FatalError $cp1Exception $fShowFatalError $ctoException $cfromException $cdisplayException\n$cfromException = \\eta::type{SomeException} -> (Case  (eta) of  [\"SomeException @e1_a5SW $dException1_a5SX e2_a5SY ->\\n  case sameTypeRep\\n         @Type\\n         @Type\\n         @e1_a5SW\\n         @FatalError\\n         (($p1Exception @e1_a5SW $dException1_a5SX)\\n          `cast` (N:Typeable[0] <Type>_N <e1_a5SW>_N\\n                  :: Typeable e1_a5SW ~R# TypeRep e1_a5SW))\\n         (($p1Exception @FatalError $fExceptionFatalError)\\n          `cast` (N:Typeable[0] <Type>_N <FatalError>_N\\n                  :: Typeable FatalError ~R# TypeRep FatalError))\\n  of {\\n    False -> Nothing @FatalError;\\n    True ->\\n      case unsafeEqualityProof\\n             @Type @(Any :~~: Any) @(e1_a5SW :~~: FatalError)\\n      of\\n      { UnsafeRefl co_a5Vy ->\\n      Just\\n        @FatalError\\n        (e2_a5SY\\n         `cast` (Sub (Nth:2 (Sub co_a5Vy))\\n                 ; Sub (Nth:3 (Sub (Sym co_a5Vy)))\\n                 :: e1_a5SW ~R# FatalError))\\n      }\\n  }\"])\n$cdisplayException = show @FatalError $p2Exception @FatalError $fExceptionFatalError\n$ctoException = \\ds::type{FatalError} -> (SomeException @FatalError $fExceptionFatalError ds)\n\n}\n\n\npanic=\\a::kind{Type} -> (\\$dIP::type{HasCallStack} -> (\\a::type{Text} -> (throw @LiftedRep @a_a5Rc @FatalError $fExceptionFatalError UTCast(a~Sym (N:FatalError[0])))))\n"
[15 of 21] Compiling Protolude.Safe   ( Protolude/Safe.hs, Protolude/Safe.o ) [Impure plugin forced recompilation]
"[]\n----\n{}\n\n{base}\n----\nmodule Protolude.Safe (Unit:main)\n\nliftMay=\\a::kind{Type} -> (\\b::kind{Type} -> (\\test::type{a_a6cq -> Bool} -> (\\f::type{a_a6cq -> b_a6cr} -> (\\val::type{a_a6cq} -> (Case  (test val) of  [\"False -> Just @b_a6cr (f_a62P val_a62Q)\",\"True -> Nothing @b_a6cr\"])))))\nheadMay=\\a::kind{Type} -> (liftMay @[a_a6cx] @a_a6cx null @[] $fFoldable[] @a_a6cx head @a_a6cx UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"head\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Safe\"#) unpackCString# Literal(\"./Protolude/Safe.hs\"#) I# Literal(49#) I# Literal(24#) I# Literal(49#) I# Literal(28#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N)))\nheadDef=\\a::kind{Type} -> (\\def::type{a_a6cK} -> (. @Maybe a_a6cK @a_a6cK @[a_a6cK] fromMaybe @a_a6cK def headMay @a_a6cK))\ninitMay=\\a::kind{Type} -> (liftMay @[a_a6cT] @[a_a6cT] null @[] $fFoldable[] @a_a6cT init @a_a6cT UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"init\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Safe\"#) unpackCString# Literal(\"./Protolude/Safe.hs\"#) I# Literal(59#) I# Literal(24#) I# Literal(59#) I# Literal(28#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N)))\ninitDef=\\a::kind{Type} -> (\\def::type{[a_a6d5]} -> (. @Maybe [a_a6d5] @[a_a6d5] @[a_a6d5] fromMaybe @[a_a6d5] def initMay @a_a6d5))\ninitSafe=\\a::kind{Type} -> (initDef @a_a6dd [] @a_a6dd)\ntailMay=\\a::kind{Type} -> (liftMay @[a_a6di] @[a_a6di] null @[] $fFoldable[] @a_a6di tail @a_a6di UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"tail\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Safe\"#) unpackCString# Literal(\"./Protolude/Safe.hs\"#) I# Literal(72#) I# Literal(24#) I# Literal(72#) I# Literal(28#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N)))\ntailDef=\\a::kind{Type} -> (\\def::type{[a_a6du]} -> (. @Maybe [a_a6du] @[a_a6du] @[a_a6du] fromMaybe @[a_a6du] def tailMay @a_a6du))\ntailSafe=\\a::kind{Type} -> (tailDef @a_a6dC [] @a_a6dC)\nlastMay=\\a::kind{Type} -> (liftMay @[a_a6dH] @a_a6dH null @[] $fFoldable[] @a_a6dH last @a_a6dH UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"last\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Safe\"#) unpackCString# Literal(\"./Protolude/Safe.hs\"#) I# Literal(85#) I# Literal(24#) I# Literal(85#) I# Literal(28#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N)))\nlastDef=\\a::kind{Type} -> (\\def::type{a_a6dT} -> (. @Maybe a_a6dT @a_a6dT @[a_a6dT] fromMaybe @a_a6dT def lastMay @a_a6dT))\nminimumMay=\\a::kind{Type} -> (\\$dOrd::type{Ord a_a6e1} -> (liftMay @[a_a6e1] @a_a6e1 null @[] $fFoldable[] @a_a6e1 minimum @[] $fFoldable[] @a_a6e1 $dOrd))\nminimumDef=\\a::kind{Type} -> (\\$dOrd::type{Ord a_a6eg} -> (\\def::type{a_a6eg} -> (. @Maybe a_a6eg @a_a6eg @[a_a6eg] fromMaybe @a_a6eg def minimumMay @a_a6eg $dOrd)))\nmaximumMay=\\a::kind{Type} -> (\\$dOrd::type{Ord a_a6er} -> (liftMay @[a_a6er] @a_a6er null @[] $fFoldable[] @a_a6er maximum @[] $fFoldable[] @a_a6er $dOrd))\nmaximumDef=\\a::kind{Type} -> (\\$dOrd::type{Ord a_a6eG} -> (\\def::type{a_a6eG} -> (. @Maybe a_a6eG @a_a6eG @[a_a6eG] fromMaybe @a_a6eG def maximumMay @a_a6eG $dOrd)))\nfoldr1May=\\a::kind{Type} -> (. @[a_a6eR] -> a_a6eR @[a_a6eR] -> Maybe a_a6eR @a_a6eR -> a_a6eR -> a_a6eR liftMay @[a_a6eR] @a_a6eR null @[] $fFoldable[] @a_a6eR foldr1 @[] $fFoldable[] @a_a6eR)\nfoldl1May=\\a::kind{Type} -> (. @[a_a6f7] -> a_a6f7 @[a_a6f7] -> Maybe a_a6f7 @a_a6f7 -> a_a6f7 -> a_a6f7 liftMay @[a_a6f7] @a_a6f7 null @[] $fFoldable[] @a_a6f7 foldl1 @[] $fFoldable[] @a_a6f7)\nfoldl1May'=\\a::kind{Type} -> (. @[a_a6fn] -> a_a6fn @[a_a6fn] -> Maybe a_a6fn @a_a6fn -> a_a6fn -> a_a6fn liftMay @[a_a6fn] @a_a6fn null @[] $fFoldable[] @a_a6fn foldl1' @a_a6fn UTCast(pushCallStack (,) @[Char] @SrcLoc unpackCString# Literal(\"foldl1'\"#) SrcLoc unpackCString# Literal(\"main\"#) unpackCString# Literal(\"Protolude.Safe\"#) unpackCString# Literal(\"./Protolude/Safe.hs\"#) I# Literal(114#) I# Literal(29#) I# Literal(114#) I# Literal(36#) emptyCallStack~Sym (N:IP[0] <\"callStack\">_N <CallStack>_N)))\nat_=\\a::kind{Type} -> (\\ys::type{[a_a6aN]} -> (\\o::type{Int} -> (Case  (< @Int $fOrdInt o I# Literal(0#)) of  [\"False ->\\n  letrec {\\n    f_a6aR [Occ=LoopBreaker] :: Int -> [a_a6aN] -> Either [Char] a_a6aN\\n    [LclId,\\n     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,\\n             WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 144] 518 10}]\\n    f_a6aR\\n      = \\\\ (ds_d6fX :: Int) (ds_d6fY :: [a_a6aN]) ->\\n          join {\\n            fail_d6g8 :: (# #) -> Either [Char] a_a6aN\\n            [LclId[JoinId(1)(Nothing)],\\n             Str=<L>,\\n             Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,\\n                     WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 450 10}]\\n            fail_d6g8 _ [Occ=Dead, OS=OneShot]\\n              = case ds_d6fY of {\\n                  [] ->\\n                    Left\\n                      @[Char]\\n                      @a_a6aN\\n                      (++\\n                         @Char\\n                         (unpackCString# \\\"index too large, index=\\\"#)\\n                         (++\\n                            @Char\\n                            (show @Int $fShowInt o_a642)\\n                            (++\\n                               @Char\\n                               (unpackCString# \\\", length=\\\"#)\\n                               (show @Int $fShowInt (- @Int $fNumInt o_a642 ds_d6fX)))));\\n                  : _ [Occ=Dead] xs_a646 ->\\n                    f_a6aR (- @Int $fNumInt ds_d6fX (I# 1#)) xs_a646\\n                } } in\\n          case ds_d6fX of { I# ds_d6g3 ->\\n          case ds_d6g3 of {\\n            __DEFAULT -> jump fail_d6g8 void#;\\n            0# ->\\n              case ds_d6fY of {\\n                __DEFAULT -> jump fail_d6g8 void#;\\n                : x_a644 _ [Occ=Dead] -> Right @[Char] @a_a6aN x_a644\\n              }\\n          }\\n          }; } in\\n  f_a6aR o_a642 ys_a641\",\"True ->\\n  Left\\n    @[Char]\\n    @a_a6aN\\n    (++\\n       @Char\\n       (unpackCString# \\\"index must not be negative, index=\\\"#)\\n       (show @Int $fShowInt o_a642))\"])))\natMay=\\a::kind{Type} -> (\\xs::type{[a_a6c7]} -> (\\i::type{Int} -> (Case  (at_ @a_a6c7 xs i) of  [\"Left _ [Occ=Dead] -> Nothing @a_a6c7\",\"Right val_a64a -> Just @a_a6c7 val_a64a\"])))\natDef=\\a::kind{Type} -> (\\def::type{a_a6ci} -> (\\xs::type{[a_a6ci]} -> (\\i::type{Int} -> (Case  (at_ @a_a6ci xs i) of  [\"Left _ [Occ=Dead] -> def_a64b\",\"Right val_a64e -> val_a64e\"]))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Safe\"#)\n"
[16 of 21] Compiling Protolude.Semiring ( Protolude/Semiring.hs, Protolude/Semiring.o ) [Impure plugin forced recompilation]
"[Semiring]\n----\n{}\n\n{base}\n----\nmodule Protolude.Semiring (Unit:main)\n\nzero=mempty\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Semiring\"#)\n$krep=KindRepTyConApp $tcConstraint [] @KindRep\n$krep=KindRepFun krep$* $krep\n$krep=$WKindRepVar I# Literal(0#)\n$krep=KindRepFun $krep $krep\n$krep=KindRepFun $krep $krep\n$krep=KindRepTyConApp $tcMonoid : @KindRep $krep [] @KindRep\n$tcSemiring=TyCon Literal(16888869637937493505##64) Literal(1250985331925574307##64) $trModule TrNameS Literal(\"Semiring\"#) Literal(0#) $krep\n$krep=KindRepTyConApp $tcSemiring : @KindRep $krep [] @KindRep\n$krep=KindRepFun $krep $krep\n$krep=KindRepFun $krep $krep\n$krep=KindRepFun $krep $krep\n$tc'C:Semiring=TyCon Literal(16407545314888395851##64) Literal(12527459471575482966##64) $trModule TrNameS Literal(\"'C:Semiring\"#) Literal(1#) $krep\n"
[17 of 21] Compiling Protolude.Show   ( Protolude/Show.hs, Protolude/Show.o ) [Impure plugin forced recompilation]
"[Print]\n----\n{(main, Protolude.Base)}\n\n{base, bytestring-0.11.3.1, text-2.0.1}\n----\nmodule Protolude.Show (Unit:main)\n\n$chPutStrLn=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a75h} -> (\\h::type{Handle} -> (. @IO () @m_a75h () @Text liftIO @m_a75h $dMonadIO @() hPutStrLn h)))\n$chPutStr=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a74R} -> (\\h::type{Handle} -> (. @IO () @m_a74R () @Text liftIO @m_a74R $dMonadIO @() hPutStr h)))\n$chPutStrLn=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a74c} -> (\\h::type{Handle} -> (. @IO () @m_a74c () @Text liftIO @m_a74c $dMonadIO @() hPutStrLn h)))\n$chPutStr=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a73M} -> (\\h::type{Handle} -> (. @IO () @m_a73M () @Text liftIO @m_a73M $dMonadIO @() hPutStr h)))\n$chPutStrLn=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a737} -> (\\h::type{Handle} -> (. @IO () @m_a737 () @ByteString liftIO @m_a737 $dMonadIO @() hPutStrLn h)))\n$chPutStr=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a72H} -> (\\h::type{Handle} -> (. @IO () @m_a72H () @ByteString liftIO @m_a72H $dMonadIO @() hPutStr h)))\n$chPutStrLn=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a722} -> (\\h::type{Handle} -> (. @IO () @m_a722 () @ByteString liftIO @m_a722 $dMonadIO @() hPutStrLn h)))\n$chPutStr=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a71C} -> (\\h::type{Handle} -> (. @IO () @m_a71C () @ByteString liftIO @m_a71C $dMonadIO @() hPutStr h)))\n$chPutStrLn=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a70X} -> (\\h::type{Handle} -> (. @IO () @m_a70X () @[Char] liftIO @m_a70X $dMonadIO @() hPutStrLn h)))\n$chPutStr=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a70x} -> (\\h::type{Handle} -> (. @IO () @m_a70x () @[Char] liftIO @m_a70x $dMonadIO @() hPutStr h)))\n$dmputErrLn=\\a::kind{Type} -> (\\$dPrint::type{Print a_a6NP} -> (\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a70j} -> (hPutStrLn @a_a6NP $dPrint @m_a70j $dMonadIO stderr))))\n$dmputStrLn=\\a::kind{Type} -> (\\$dPrint::type{Print a_a6NP} -> (\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a708} -> (hPutStrLn @a_a6NP $dPrint @m_a708 $dMonadIO stdout))))\n$dmputStr=\\a::kind{Type} -> (\\$dPrint::type{Print a_a6NP} -> (\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a6ZX} -> (hPutStr @a_a6NP $dPrint @m_a6ZX $dMonadIO stdout))))\n\nREC {\n$fPrint[] = C:Print @[Char] $chPutStr $cputStr $chPutStrLn $cputStrLn $cputErrLn\n$cputStrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a71b} -> ($dmputStrLn @[Char] $fPrint[] @m_a71b $dMonadIO))\n$cputErrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a71n} -> ($dmputErrLn @[Char] $fPrint[] @m_a71n $dMonadIO))\n$cputStr = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a70L} -> ($dmputStr @[Char] $fPrint[] @m_a70L $dMonadIO))\n\n}\n\n\n\nREC {\n$fPrintByteString = C:Print @ByteString $chPutStr $cputStr $chPutStrLn $cputStrLn $cputErrLn\n$cputStrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a72g} -> ($dmputStrLn @ByteString $fPrintByteString @m_a72g $dMonadIO))\n$cputErrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a72s} -> ($dmputErrLn @ByteString $fPrintByteString @m_a72s $dMonadIO))\n$cputStr = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a71Q} -> ($dmputStr @ByteString $fPrintByteString @m_a71Q $dMonadIO))\n\n}\n\n\n\nREC {\n$fPrintByteString0 = C:Print @ByteString $chPutStr $cputStr $chPutStrLn $cputStrLn $cputErrLn\n$cputStrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a73l} -> ($dmputStrLn @ByteString $fPrintByteString0 @m_a73l $dMonadIO))\n$cputErrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a73x} -> ($dmputErrLn @ByteString $fPrintByteString0 @m_a73x $dMonadIO))\n$cputStr = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a72V} -> ($dmputStr @ByteString $fPrintByteString0 @m_a72V $dMonadIO))\n\n}\n\n\n\nREC {\n$fPrintText = C:Print @Text $chPutStr $cputStr $chPutStrLn $cputStrLn $cputErrLn\n$cputStrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a74q} -> ($dmputStrLn @Text $fPrintText @m_a74q $dMonadIO))\n$cputErrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a74C} -> ($dmputErrLn @Text $fPrintText @m_a74C $dMonadIO))\n$cputStr = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a740} -> ($dmputStr @Text $fPrintText @m_a740 $dMonadIO))\n\n}\n\n\n\nREC {\n$fPrintText0 = C:Print @Text $chPutStr $cputStr $chPutStrLn $cputStrLn $cputErrLn\n$cputStrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a75v} -> ($dmputStrLn @Text $fPrintText0 @m_a75v $dMonadIO))\n$cputErrLn = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a75H} -> ($dmputErrLn @Text $fPrintText0 @m_a75H $dMonadIO))\n$cputStr = \\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a755} -> ($dmputStr @Text $fPrintText0 @m_a755 $dMonadIO))\n\n}\n\n\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Show\"#)\n$krep=KindRepTyConApp $tcConstraint [] @KindRep\n$krep=KindRepFun krep$* $krep\n$tcPrint=TyCon Literal(11752663600977558150##64) Literal(7300618673989366300##64) $trModule TrNameS Literal(\"Print\"#) Literal(0#) $krep\n$sputErrText=putErrLn @Text $fPrintText0 @IO $fMonadIOIO\nputErrText=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a6Yi} -> (putErrLn @Text $fPrintText0 @m_a6Yi $dMonadIO))\n$sputLByteString=putStrLn @ByteString $fPrintByteString @IO $fMonadIOIO\nputLByteString=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a6YC} -> (putStrLn @ByteString $fPrintByteString @m_a6YC $dMonadIO))\n$sputByteString=putStrLn @ByteString $fPrintByteString0 @IO $fMonadIOIO\nputByteString=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a6YW} -> (putStrLn @ByteString $fPrintByteString0 @m_a6YW $dMonadIO))\n$sputLText=putStrLn @Text $fPrintText @IO $fMonadIOIO\nputLText=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a6Zg} -> (putStrLn @Text $fPrintText @m_a6Zg $dMonadIO))\n$sputText=putStrLn @Text $fPrintText0 @IO $fMonadIOIO\nputText=\\m::kind{Type -> Type} -> (\\$dMonadIO::type{MonadIO m_a6ZA} -> (putStrLn @Text $fPrintText0 @m_a6ZA $dMonadIO))\n"
[18 of 21] Compiling Protolude.Debug  ( Protolude/Debug.hs, Protolude/Debug.o ) [Impure plugin forced recompilation]
"[]\n----\n{(main, Protolude.Base), (main, Protolude.Error),\n (main, Protolude.Show)}\n\n{base, text-2.0.1}\n----\nmodule Protolude.Debug (Unit:main)\n\ntrace=\\b::kind{Type} -> (\\a::kind{Type} -> (\\$dPrint::type{Print b_a7pG} -> (\\string::type{b_a7pG} -> (\\expr::type{a_a7pH} -> (unsafePerformIO @a_a7pH >> @IO $fMonadIO @() @a_a7pH hPutStrLn @b_a7pG $dPrint @IO $fMonadIOIO stderr string return @IO $fMonadIO @a_a7pH expr)))))\ntraceShow=\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dShow::type{Show a_a7q7} -> (\\a::type{a_a7q7} -> (\\b::type{b_a7q8} -> (trace @String @b_a7q8 $fPrint[] show @a_a7q7 $dShow a b)))))\ntraceShowId=\\a::kind{Type} -> (\\$dShow::type{Show a_a7qi} -> (\\a::type{a_a7qi} -> (trace @String @a_a7qi $fPrint[] show @a_a7qi $dShow a a)))\ntraceShowM=\\a::kind{Type} -> (\\m::kind{Type -> Type} -> (\\$dShow::type{Show a_a7qs} -> (\\$dMonad::type{Monad m_a7qt} -> (\\a::type{a_a7qs} -> (trace @String @m_a7qt () $fPrint[] show @a_a7qs $dShow a return @m_a7qt $dMonad @() ())))))\ntraceM=\\m::kind{Type -> Type} -> (\\$dMonad::type{Monad m_a7qH} -> (\\s::type{Text} -> (trace @String @m_a7qH () $fPrint[] unpack s return @m_a7qH $dMonad @() ())))\ntraceIO=\\b::kind{Type} -> (\\a::kind{Type} -> (\\$dPrint::type{Print b_a7pm} -> (\\string::type{b_a7pm} -> (\\expr::type{a_a7pn} -> (>> @IO $fMonadIO @() @a_a7pn hPutStrLn @b_a7pm $dPrint @IO $fMonadIOIO stderr string return @IO $fMonadIO @a_a7pn expr)))))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude.Debug\"#)\ntraceId=\\s::type{Text} -> (trace @Text @Text $fPrintText0 s s)\n"
[19 of 21] Compiling Protolude        ( Protolude.hs, Protolude.o ) [Impure plugin forced recompilation]
"[LByteString, LText]\n----\n{(main, Protolude.Applicative), (main, Protolude.Base),\n (main, Protolude.Bool), (main, Protolude.Conv),\n (main, Protolude.ConvertText), (main, Protolude.Debug),\n (main, Protolude.Either), (main, Protolude.Exceptions),\n (main, Protolude.Functor), (main, Protolude.List),\n (main, Protolude.Monad), (main, Protolude.Panic),\n (main, Protolude.Safe), (main, Protolude.Semiring),\n (main, Protolude.Show)}\n\n{base, bytestring-0.11.3.1, containers-0.6.6, deepseq-1.4.8.0,\n mtl-2.2.2, stm-2.5.1.0, text-2.0.1, transformers-0.5.6.2}\n----\nmodule Protolude (Unit:main)\n\nidentity=\\a::kind{Type} -> (\\x::type{a_a9i9} -> (x))\napplyN=\\a::kind{Type} -> (\\n::type{Int} -> (\\f::type{a_a9ic -> a_a9ic} -> (foldr @[] $fFoldable[] @a_a9ic -> a_a9ic @a_a9ic -> a_a9ic . @a_a9ic @a_a9ic @a_a9ic identity @a_a9ic replicate @a_a9ic -> a_a9ic n f)))\nmap=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dFunctor::type{Functor f_a9hY} -> (fmap @f_a9hY $dFunctor @a_a9hZ @b_a9i0))))\nuncons=\\a::kind{Type} -> (\\ds::type{[a_a9hQ]} -> (Case  (ds) of  [\"[] -> Nothing @(a_a9hQ, [a_a9hQ])\",\": x_a93S xs_a93T -> Just @(a_a9hQ, [a_a9hQ]) (x_a93S, xs_a93T)\"]))\nunsnoc=\\x::kind{Type} -> (foldr @[] $fFoldable[] @x_a9h9 @Maybe ([x_a9h9], x_a9h9) \\x::type{x_a9h9} -> (\\mxs::type{Maybe ([x_a9h9], x_a9h9)} -> (Just @([x_a9h9], x_a9h9) Case  (mxs) of  [\"Nothing -> ([] @x_a9h9, x_a93V)\",\"Just ds_d9jX ->\\n  case ds_d9jX of { (xs_a93X, e_a93Y) ->\\n  (: @x_a9h9 x_a93V xs_a93X, e_a93Y)\\n  }\"])) Nothing @([x_a9h9], x_a9h9))\nreadMaybe=\\b::kind{Type} -> (\\a::kind{Type} -> (\\$dRead::type{Read b_a9gT} -> (\\$dStringConv::type{StringConv a_a9gU String} -> (. @String @Maybe b_a9gT @a_a9gU readMaybe @b_a9gT $dRead toS @a_a9gU @String $dStringConv))))\nreadEither=\\a::kind{Type} -> (\\e::kind{Type} -> (\\$dRead::type{Read a_a9gl} -> (\\$dStringConv::type{StringConv String e_a9gm} -> (\\$dStringConv::type{StringConv e_a9gm String} -> (. @Either String a_a9gl @Either e_a9gm a_a9gl @e_a9gm first @Either $fBifunctorEither @String @e_a9gm @a_a9gl toS @String @e_a9gm $dStringConv . @String @Either String a_a9gl @e_a9gm readEither @a_a9gl $dRead toS @e_a9gm @String $dStringConv)))))\nprint=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dMonadIO::type{MonadIO m_a9g5} -> (\\$dShow::type{Show a_a9g6} -> (. @IO () @m_a9g5 () @a_a9g6 liftIO @m_a9g5 $dMonadIO @() print @a_a9g6 $dShow))))\nthrowIO=\\m::kind{Type -> Type} -> (\\e::kind{Type} -> (\\a::kind{Type} -> (\\$dMonadIO::type{MonadIO m_a9fM} -> (\\$dException::type{Exception e_a9fN} -> (. @IO a_a9fO @m_a9fM a_a9fO @e_a9fN liftIO @m_a9fM $dMonadIO @a_a9fO throwIO @e_a9fN @a_a9fO $dException)))))\nthrowTo=\\m::kind{Type -> Type} -> (\\e::kind{Type} -> (\\$dMonadIO::type{MonadIO m_a9fz} -> (\\$dException::type{Exception e_a9fA} -> (\\tid::type{ThreadId} -> (\\e::type{e_a9fA} -> (liftIO @m_a9fz $dMonadIO @() throwTo @e_a9fA $dException tid e))))))\npass=\\f::kind{Type -> Type} -> (\\$dApplicative::type{Applicative f_a9fr} -> (pure @f_a9fr $dApplicative @() ()))\nguarded=\\f::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dAlternative::type{Alternative f_a9fe} -> (let  ($dApplicative=$p1Alternative @f_a9fe $dAlternative) in\\p::type{a_a9ff -> Bool} -> (\\x::type{a_a9ff} -> (bool @f_a9fe a_a9ff empty @f_a9fe $dAlternative @a_a9ff pure @f_a9fe $dApplicative @a_a9ff x p x)))))\nguardedA=\\f::kind{Type -> Type} -> (\\t::kind{Type -> Type} -> (\\a::kind{Type} -> (\\$dFunctor::type{Functor f_a9eU} -> (\\$dAlternative::type{Alternative t_a9eV} -> (let  ($dApplicative=$p1Alternative @t_a9eV $dAlternative) in\\p::type{a_a9eW -> f_a9eU Bool} -> (\\x::type{a_a9eW} -> (fmap @f_a9eU $dFunctor @Bool @t_a9eV a_a9eW bool @t_a9eV a_a9eW empty @t_a9eV $dAlternative @a_a9eW pure @t_a9eV $dApplicative @a_a9eW x p x)))))))\nliftIO1=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dMonadIO::type{MonadIO m_a9eH} -> (. @IO b_a9eJ @m_a9eH b_a9eJ @a_a9eI liftIO @m_a9eH $dMonadIO @b_a9eJ))))\nliftIO2=\\m::kind{Type -> Type} -> (\\a::kind{Type} -> (\\b::kind{Type} -> (\\c::kind{Type} -> (\\$dMonadIO::type{MonadIO m_a9en} -> (. @(b_a9ep -> IO c_a9eq) -> b_a9ep -> m_a9en c_a9eq @(a_a9eo -> b_a9ep -> IO c_a9eq)\n-> a_a9eo -> b_a9ep -> m_a9en c_a9eq @IO c_a9eq -> m_a9en c_a9eq . @b_a9ep -> IO c_a9eq @b_a9ep -> m_a9en c_a9eq @a_a9eo . @IO c_a9eq @m_a9en c_a9eq @b_a9ep liftIO @m_a9en $dMonadIO @c_a9eq)))))\n$sshow=\\a::kind{Type} -> (\\$dShow::type{Show a_a9ee} -> (\\x::type{a_a9ee} -> (toS @String @String $fStringConv[][] show @a_a9ee $dShow x)))\n$sshow=\\a::kind{Type} -> (\\$dShow::type{Show a_a9dM} -> (\\x::type{a_a9dM} -> (toS @String @LText $fStringConv[]Text show @a_a9dM $dShow x)))\n$sshow=\\a::kind{Type} -> (\\$dShow::type{Show a_a9dk} -> (\\x::type{a_a9dk} -> (toS @String @Text $fStringConv[]Text0 show @a_a9dk $dShow x)))\nshow=\\a::kind{Type} -> (\\b::kind{Type} -> (\\$dShow::type{Show a_a9cN} -> (\\$dStringConv::type{StringConv String b_a9cO} -> (\\x::type{a_a9cN} -> (toS @String @b_a9cO $dStringConv show @a_a9cN $dShow x)))))\ndie=\\a::kind{Type} -> (\\err::type{Text} -> (die @a_a9cC toS @Text @String $fConvertTextText[]0 err))\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Protolude\"#)\n"
[20 of 21] Compiling Main             ( basic.hs, basic.o ) [Impure plugin forced recompilation]
"[]\n----\n{(main, Basici), (main, Protolude)}\n\n{}\n----\nmodule Main (Unit:main)\n\n$trModule=Module TrNameS Literal(\"main\"#) TrNameS Literal(\"Main\"#)\nmain=putStrLn @[Char] $fPrint[] @IO $fMonadIOIO show @Integer @[Char] $fShowInteger $fStringConv[][] inc @Integer $fNumInteger IS Literal(0#)\nmain=runMainIO @() main\n"
[21 of 21] Linking basic [Objects changed]
/workspaces/GhcCore
